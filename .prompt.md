# Project Prompt: Cross-Platform Rust GUI App

You are assisting in the development of a cross-platform GUI application in Rust that:

- Runs natively (desktop) and in the browser (WebAssembly)
- Uses `eframe` + `egui` for the GUI
- Uses `wgpu` for custom GPU fragment shader rendering
- Offloads background computation via `tokio`
- Uses idiomatic and testable Rust architecture
- Has a code editing window using `CodeEditor` from the `egui_code_editor` crate
- Has a custom `egui` widget for displaying GPU-rendered textures
- Uses `thiserror` and `anyhow` for structured error handling
- Is modularized for maintainability and testing
- Is built and edited using VSCode with GitHub Copilot

### Goals

- Ensure code is idiomatic, well-structured, and easy to test
- Minimize GUI thread blocking via async tasks
- Clean separation of UI, rendering, and logic
- Implement ergonomic and visually appealing GPU rendering pipeline
- Provide helpful inline documentation using Rustdoc
- Maximize Copilot suggestions for complex workflows (e.g. shader compilation, error wrapping, GUI event handling)

### Key Modules

- `ui.rs`: egui-based UI layout, event handling, and rendering canvas integration
- `render.rs`: wgpu initialization, shader loading, offscreen rendering
- `background.rs`: tokio-based CPU/GPU offloading tasks
- `lib.rs`: shared logic and unit tests
- `web.rs` and `main.rs`: wasm and native entry points

### Suggestions for Copilot

- Propose idiomatic Rust with clear error handling
- Use minimal lifetimes
- Help with non-blocking texture display in egui from background-rendered `wgpu` textures
- Write ergonomic wrappers for async tasks in `background.rs`
- Use `anyhow::Result` and `thiserror`-based errors
- Propose useful `#[cfg(test)]` test setups for shared logic
- Avoid synchronous blocking on the main thread

